---
alwaysApply: true
description: Ludium Backend development guidelines and V2 architecture protection rules
---

# Cursor AI Agent for Ludium Backend

## ğŸ¯ Project Overview

This is the official backend API for the Ludium Portal, a global platform for Web3 builders. The project provides a robust, scalable, and secure GraphQL API to support our frontend application and open-source contributors.

**Key Context:**

- Monolithic API architecture (not microservices)
- Primary interface: GraphQL API at `/graphql` endpoint
- REST endpoints only for specific cases (webhooks, health checks)
- Transitioning to open-source model - clarity and documentation are paramount

## ğŸ—ï¸ Architecture & Technology Stack

### Core Technologies:

- **Language:** TypeScript with strict typing
- **Framework:** Fastify (high-performance Node.js framework)
- **Database:** PostgreSQL with Drizzle ORM
- **GraphQL:** Mercurius (Fastify plugin) + Pothos (code-first schema builder)
- **Authentication:** JWT-based with Argon2 password hashing
- **Containerization:** Docker and Docker Compose

### Data Flow:

1. GraphQL requests â†’ `/graphql` endpoint
2. Fastify server processes through plugins (auth, file uploads)
3. GraphQL resolvers handle business logic
4. Drizzle ORM interacts with PostgreSQL

## ğŸ“ Key Directories & Workflow

### Database Changes (First Step):

- **`src/db/schemas/`** - Drizzle ORM schema definitions
- **`src/db/migrations/`** - Auto-generated SQL migrations (DO NOT EDIT)

### API Changes (First Step):

- **`src/graphql/types/`** - Pothos schema definitions (GraphQL types, queries, mutations)
- **`src/graphql/resolvers/`** - Business logic implementation
- **`src/graphql/schema.graphql`** - Auto-generated (DO NOT EDIT)

### Other Important Directories:

- **`src/plugins/`** - Core Fastify plugins (auth, database connection)
- **`src/utils/`** - Utility functions for complex business logic

## ğŸ”§ Coding Standards & Conventions

> **ğŸ“š ì°¸ê³ **: ì¼ë°˜ì ì¸ Fastify, GraphQL, TypeScript ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤ëŠ” [@best-practices.mdc](mdc:@best-practices.mdc)ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”.

### í”„ë¡œì íŠ¸ íŠ¹í™” ê·œì¹™:

#### GraphQL Documentation:

- **Updating:** v2 ìŠ¤í‚¤ë§ˆ ë³€ê²½ ì‹œ GRAPHQL_EXAMPLES.md ë¬¸ì„œë¥¼ ë°˜ë“œì‹œ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”.

#### í”„ë¡œì íŠ¸ ë„¤ì´ë° ê·œì¹™:

- **Imports:** ALWAYS use absolute path aliases (`@/db/schemas`) - NEVER relative paths
- **Comments:** Explain "why" (business logic) not just "what"

#### Database (Drizzle ORM):

- **Schema Files:** Each table gets its own file in `src/db/schemas/`
- **Table Naming:** `camelCase` + `Table` (e.g., `usersTable`, `programsTable`)
- **Migrations:** NEVER modify schema directly - update schema files, then run `npm run db:gen`

#### GraphQL (í”„ë¡œì íŠ¸ íŠ¹í™”):

- **Schema Builder:** Use Pothos for code-first, type-safe approach
- **Domain Structure:** API definitions (`types`)ì™€ business logic (`resolvers`) ë¶„ë¦¬

## ğŸ›¡ï¸ V2 Architecture Protection

### V2 Architecture Rules (NON-NEGOTIABLE)

The V2 architecture follows a strict modular pattern that MUST be maintained:

```
src/graphql/v2/
â”œâ”€â”€ types/           # GraphQL type definitions (API contracts)
â”œâ”€â”€ resolvers/       # Business logic implementation
â”œâ”€â”€ mutations/       # Mutation definitions (data modification)
â”œâ”€â”€ queries/         # Query definitions (data retrieval)
â”œâ”€â”€ inputs/          # Input type definitions (validation)
â””â”€â”€ tests/           # Comprehensive test suite
```

#### Critical V2 Rules:

- **NEVER** mix V1 and V2 code in the same files
- **ALWAYS** create new files in the appropriate V2 subdirectory
- **NEVER** modify `src/graphql/builder.ts` for V2-specific code
- **ALWAYS** maintain the separation between types, resolvers, mutations, and queries
- **MUST** follow naming conventions: `{Entity}V2Type`, `{Action}{Entity}V2Input`, `{action}{Entity}V2Resolver`

#### When to Use V2:

- **NEW** features must use V2 architecture
- **MAJOR** refactoring of existing features should migrate to V2
- **CRITICAL** features should prioritize V2 implementation

## ğŸš€ Common Development Tasks

### Adding a New GraphQL Query/Mutation (V2 Architecture)

This project follows a **domain-centric structure** where API definitions (`types`) are separated from their business logic (`resolvers`).

#### For V2 Features (RECOMMENDED):

1.  **Create V2 Directory Structure**

    ```bash
    mkdir -p src/graphql/v2/{types,resolvers,mutations,queries,inputs,tests}
    ```

2.  **Define the API Specification (`/graphql/v2/types/`)**

    - Create new file: `src/graphql/v2/types/{entity}.ts`
    - **Define Object Types:** Create the GraphQL object shape using `builder.objectRef`, e.g., `EntityV2Type`
    - **Define Input Types:** Define input types using `builder.inputType`, e.g., `CreateEntityV2Input`
    - **Add Queries/Mutations:** Use `builder.queryFields` or `builder.mutationFields` to expose API endpoints
    - **Connect to Resolver:** Use the `resolve` property to link to resolver functions

3.  **Implement the Business Logic (`/graphql/v2/resolvers/`)**

    - Create new file: `src/graphql/v2/resolvers/{entity}.ts`
    - Create `async` functions with naming pattern: `{action}{Entity}V2Resolver`
    - Implement business logic: database queries, data transformation, permission checks

4.  **Add Input Definitions (`/graphql/v2/inputs/`)**

    - Create new file: `src/graphql/v2/inputs/{entity}.ts`
    - Define all input types for the entity
    - Include validation and documentation

5.  **Create Comprehensive Tests (`/graphql/v2/tests/`)**

    - Create new file: `src/graphql/v2/tests/{entity}.test.ts`
    - Cover all CRUD operations and edge cases
    - Minimum 90% test coverage required

6.  **Important V2 Rules:**
    - **NEVER** modify `src/graphql/builder.ts` for V2-specific code
    - **ALWAYS** use V2 naming conventions
    - **MUST** maintain separation between types, resolvers, mutations, and queries
    - **MUST** include comprehensive JSDoc documentation

#### For V1 Features (LEGACY - Use V2 when possible):

1.  **Define the API Specification (`/graphql/types/`)**

    - Open the relevant file, e.g., `src/graphql/types/programs-v2.ts`.
    - **Define Object Types:** Create the GraphQL object shape using `builder.objectRef`, e.g., `ProgramV2Type`. This defines what the client can query.
    - **Define Input Types:** If your mutation needs arguments, define them using `builder.inputType`, e.g., `CreateProgramV2Input`.
    - **Add Queries/Mutations:** In the _same file_, use `builder.queryFields` or `builder.mutationFields` to expose the new API endpoint.
    - **Connect to Resolver:** In the field definition, use the `resolve` property to link to the resolver function that will contain the business logic (e.g., `resolve: getProgramV2Resolver`).

2.  **Implement the Business Logic (`/graphql/resolvers/`)**

    - Open the corresponding resolver file, e.g., `src/graphql/resolvers/programs-v2.ts`.
    - Create an `async` function with the exact name you used in the `resolve` property (e.g., `export async function getProgramV2Resolver(...)`).
    - Inside this function, implement the actual logic: database queries (with Drizzle), data transformation, permission checks, etc.

3.  **Important Notes:**
    - **`src/graphql/builder.ts` is for global setup only.** Do NOT add domain-specific queries or mutations there.
    - This separation ensures that `types` files describe **what** the API looks like, and `resolvers` files describe **how** it works.

### Modifying Database Schema:

1. **Update Schema:** Modify appropriate file in `src/db/schemas/`
2. **Generate Migration:** Run `npm run db:gen`
3. **Review:** Check generated `.sql` file in `src/db/migrations/`

### Code Refactoring:

- Extract complex business logic from resolvers to `src/utils/`
- Maintain separation of concerns (resolvers = API, utils = business logic)
- Ensure strong typing and clear naming

## ğŸš¨ Critical Constraints & Non-Negotiables

### NEVER Access These Files:

- `.env*` files
- `.gcp.json`
- `docker-compose.yml`
- `*.sql` files in migrations
- `src/graphql/schema.graphql`

### Dependencies:

- Do NOT add third-party libraries without explicit instruction
- Keep dependency tree lean and secure

### Code Quality (í”„ë¡œì íŠ¸ íŠ¹í™”):

- All code MUST pass Biome checks (`npm run check`)
- Do NOT manually edit auto-generated files
- Use absolute imports exclusively (`@/` prefix)
- **Formatting:** Use Biome (`npm run check` before committing)
- **Naming Conventions:**
  - Interfaces, Types, Classes: `PascalCase`
  - Files: `kebab-case`
  - Constants: `UPPER_SNAKE_CASE`
  - Enums: `PascalCase` for enum, `UPPER_SNAKE_CASE` for members
  - Variables, Functions: `camelCase`

## ğŸ“‹ Development Checklist

### Before Making Changes:

- [ ] Understand the monolithic architecture
- [ ] Identify correct directory for changes (types vs resolvers vs schemas)
- [ ] Check existing patterns in similar files
- [ ] Plan for proper error handling

### Database Changes:

- [ ] Update schema file in `src/db/schemas/`
- [ ] Run `npm run db:gen` for migration
- [ ] Review generated migration file
- [ ] Test database operations

### GraphQL Changes:

- [ ] Define types in `src/graphql/types/`
- [ ] Implement resolvers in `src/graphql/resolvers/`
- [ ] Add proper error handling
- [ ] Include JSDoc documentation
- [ ] Test with GraphQL playground

### Code Quality:

- [ ] Use absolute imports (`@/` prefix)
- [ ] Follow naming conventions
- [ ] Add meaningful comments
- [ ] Run `npm run check` before committing
- [ ] Extract complex logic to utils when appropriate

## ğŸ¨ Best Practices

> **ğŸ“š ì°¸ê³ **: ì¼ë°˜ì ì¸ ì—ëŸ¬ í•¸ë“¤ë§, ë¡œê¹…, ì„±ëŠ¥ ìµœì í™” ë°©ë²•ì€ [@best-practices.mdc](mdc:@best-practices.mdc)ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”.

### í”„ë¡œì íŠ¸ íŠ¹í™” íŒ¨í„´:

#### Error Handling (Ludium ìŠ¤íƒ€ì¼):

```typescript
try {
  const result = await ctx.db.select()...;
  ctx.server.log.info({ msg: "Operation completed", result });
} catch (error) {
  ctx.server.log.error({
    msg: "Database operation failed",
    error: error.message,
    operation: "operation_name"
  });
  throw new Error("User-friendly error message");
}
```

#### Logging (í”„ë¡œì íŠ¸ ê·œì¹™):

- Use Fastify logger (`ctx.server.log`) instead of `console.log`
- Include structured logging with metadata
- Use appropriate log levels (info, warn, error, debug)

#### GraphQL Resolvers (ë„ë©”ì¸ êµ¬ì¡°):

- Keep resolvers focused on API concerns
- Extract business logic to utility functions (`src/utils/`)
- Include proper TypeScript types
- Handle errors gracefully

#### Performance (í”„ë¡œì íŠ¸ íŠ¹í™”):

- Use transactions for multi-step database operations
- Consider timeout scenarios for long-running queries
- Include query execution time logging
- Monitor database connection pool status
- Track response times and error rates

Remember: This is an open-source project transitioning to community contributions. Code clarity, documentation, and adherence to standards are paramount for all work.
